/***********************
 * BAXIE BREEDING (v1.3)
 * - Body không bao giờ là Mystic
 * - Mystic là part đặc biệt (text "Mystic"), không gắn element
 * - Đọc phần trăm robust (0,50%/0.50%/0,50/0.50)
 ***********************/
const CFG = {
  DATA_SHEET: "DATA",
  BREED_SHEET: "Breeding",

  // IDs
  CELL_PARENT_A_ID: "B1",
  CELL_PARENT_B_ID: "D1",
  CELL_PARENT_A_ROW: "B2",
  CELL_PARENT_B_ROW: "D2",

  // Preview cha/mẹ (Body, Forehead, Eyes, Ears, Mouth, Tail)
  CELLS_PARENT_A_PARTS: ["B6","B7","B8","B9","B10","B11"],
  CELLS_PARENT_B_PARTS: ["D6","D7","D8","D9","D10","D11"],

  // Config (cột B)
  CELL_WEIGHT_A:     "B13",
  CELL_WEIGHT_B:     "B14",
  CELL_CH_PARENTS:   "B16", // 70%
  CELL_CH_VARIATION: "B17", // 25%
  CELL_CH_MUTATION:  "B18", // 5%
  CELL_CH_MYSTIC:    "B19", // 0,50%

  // Ghi kết quả
  OUTPUT_ANCHOR: "F2",

  // Ghi log cấu hình đã dùng (để bạn nhìn thấy ngay)
  CELL_DEBUG: "F1",
};

const ELEMENTS = ["fire","aqua","demon","fairy","electric","plant"];

/* ================= MENU ================= */
function onOpen(){
  SpreadsheetApp.getUi().createMenu("Baxie Tools")
    .addItem("Breed (5 offspring)","breedFive")
    .addToUi();
}

/* ================ MAIN ================== */
function breedFive() {
  const ss = SpreadsheetApp.getActive();
  const shData = ss.getSheetByName(CFG.DATA_SHEET);
  const sh = ss.getSheetByName(CFG.BREED_SHEET);

  const idA = sh.getRange(CFG.CELL_PARENT_A_ID).getValue();
  const idB = sh.getRange(CFG.CELL_PARENT_B_ID).getValue();
  if (!idA || !idB) return uiAlert("Nhập Parent A/B ID ở B1 và D1.");

  // Tìm dòng trong DATA (ID ở A2:A)
  const ids = shData.getRange("A2:A").getValues().flat();
  const iA = ids.findIndex(v => v == idA);
  const iB = ids.findIndex(v => v == idB);
  if (iA < 0 || iB < 0) return uiAlert("Không tìm thấy ID trong DATA.");
  const rA = iA + 2, rB = iB + 2;

  sh.getRange(CFG.CELL_PARENT_A_ROW).setValue(rA);
  sh.getRange(CFG.CELL_PARENT_B_ROW).setValue(rB);

  const A = readBaxieRow(shData, rA);
  const B = readBaxieRow(shData, rB);
  writePreview(sh, CFG.CELLS_PARENT_A_PARTS, A.parts);
  writePreview(sh, CFG.CELLS_PARENT_B_PARTS, B.parts);

  // Đọc tỉ lệ (robust)
  const wA = readPercent(sh.getRange(CFG.CELL_WEIGHT_A));     // ex: 50% -> 0.5
  const wB = readPercent(sh.getRange(CFG.CELL_WEIGHT_B));
  let pParents   = readPercent(sh.getRange(CFG.CELL_CH_PARENTS));   // 0.70
  let pVariation = readPercent(sh.getRange(CFG.CELL_CH_VARIATION)); // 0.25
  let pMutation  = readPercent(sh.getRange(CFG.CELL_CH_MUTATION));  // 0.05
  const pMystic  = readMysticPercent(sh.getRange(CFG.CELL_CH_MYSTIC)); // 0.005 for 0,50%

  // Chuẩn hóa 3 nhánh (nếu người dùng nhập sai tổng > 1)
  const sum = pParents + pVariation + pMutation;
  if (sum > 1) {
    pParents   /= sum;
    pVariation /= sum;
    pMutation  /= sum;
  }

  // Log cấu hình đã dùng
  sh.getRange(CFG.CELL_DEBUG).setValue(
    `Used: wA=${(wA*100).toFixed(1)}% wB=${(wB*100).toFixed(1)}% | Parents=${(pParents*100).toFixed(1)}% Var=${(pVariation*100).toFixed(1)}% Mut=${(pMutation*100).toFixed(1)}% | Mystic=${(pMystic*100).toFixed(2)}%`
  );

  // Sinh 5 offspring
  const out = [];
  for (let i = 0; i < 5; i++) {
    const c = breedOne(A, B, {wA, wB, pParents, pVariation, pMutation, pMystic});
    out.push([i+1, c.gender, c.parts[0], c.parts[1], c.parts[2], c.parts[3], c.parts[4], c.parts[5]]);
  }

  // Ghi ra bảng
  const header = [["#", "Gender", "Body", "Forehead", "Eyes", "Ears", "Mouth", "Tail"]];
  const anchor = sh.getRange(CFG.OUTPUT_ANCHOR);
  sh.getRange(anchor.getRow(), anchor.getColumn(), 1, header[0].length).setValues(header);
  sh.getRange(anchor.getRow()+1, anchor.getColumn(), out.length, out[0].length).setValues(out);
}

/* ================ HELPERS =============== */
function uiAlert(m){ SpreadsheetApp.getUi().alert(m); }

function readBaxieRow(shData, row) {
  const v = shData.getRange(row, 1, 1, 27).getValues()[0]; // A..AA
  // G..L: Body, Forehead, Eyes, Ears, Mouth, Tail
  const parts = [v[6], v[7], v[8], v[9], v[10], v[11]];
  const gender = v[2];      // C
  const elementBody = v[3]; // D
  return { parts, gender, elementBody };
}
function writePreview(sh, cells, parts) {
  for (let i=0; i<cells.length; i++)
    sh.getRange(cells[i]).setValue(parts[i] || "");
}

/** Đọc % bình thường: 70%/70/0.70 → 0.7  */
function readPercent(range) {
  const val = range.getValue();
  const fmt = range.getNumberFormat ? range.getNumberFormat() : "";
  if (typeof val === "number") {
    // nếu format là Percent thì val đã là số thập phân đúng (70% = 0.7; 0,50% = 0.005)
    if (typeof fmt === "string" && fmt.includes("%")) return clamp01(val);
    // nếu không phải percent-format: người dùng có thể gõ 70 → coi là 70%
    return clamp01(val > 1 ? val/100 : val);
  }
  if (typeof val === "string") {
    const s = val.replace("%","").replace(",",".").trim();
    if (s === "") return 0;
    const n = parseFloat(s);
    if (isNaN(n)) return 0;
    return clamp01(val.includes("%") ? n/100 : (n > 1 ? n/100 : n));
  }
  return 0;
}

/** Đọc % riêng cho mystic: nếu người dùng gõ 0.5 (không có %), ta hiểu là 0.5% (=0.005) */
function readMysticPercent(range) {
  const val = range.getValue();
  const fmt = range.getNumberFormat ? range.getNumberFormat() : "";
  if (typeof val === "number") {
    if (typeof fmt === "string" && fmt.includes("%")) return clamp01(val); // sheet xử lý sẵn: 0,50% -> 0.005
    // người dùng gõ 0.5 → hiểu là 0.5%
    return clamp01(val <= 1 ? val/100 : val/100); // 0.5 -> 0.005 ; 1 -> 0.01 ; 50 -> 0.5
  }
  if (typeof val === "string") {
    const hasPct = val.includes("%");
    const n = parseFloat(val.replace("%","").replace(",","."));
    if (isNaN(n)) return 0;
    return clamp01(hasPct ? n/100 : (n <= 1 ? n/100 : n/100));
  }
  return 0;
}

function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function pickWeighted(aVal, bVal, wA, wB) {
  return (Math.random() * (wA + wB) < wA) ? aVal : bVal;
}
function randChoice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function unique(a){ return [...new Set(a)]; }
function normalizeElement(s) {
  if (!s || typeof s !== "string") return "";
  const t = s.toLowerCase().trim().replace(/^mystic\s+/,"");
  for (const e of ELEMENTS) if (t.startsWith(e)) return e;
  return "";
}

/** Core breeding theo rule của bạn */
function breedOne(A, B, cfg) {
  const out = [];
  let bodyElement = null;

  for (let i=0; i<6; i++) {
    const pa = (A.parts[i] || "").trim();
    const pb = (B.parts[i] || "").trim();
    const elA = normalizeElement(pa);
    const elB = normalizeElement(pb);
    const pairEls = unique([elA, elB].filter(Boolean));

    // Nhánh: parents / variation / mutation
    const r = Math.random();
    let base = "";
    if (r < cfg.pParents) {
      base = pickWeighted(pa, pb, cfg.wA, cfg.wB);
    } else if (r < cfg.pParents + cfg.pVariation) {
      const pickEl = pairEls.length ? randChoice(pairEls) : (bodyElement || randChoice(ELEMENTS));
      base = pickEl + " (Variant)";
    } else {
      const others = ELEMENTS.filter(e => !pairEls.includes(e));
      const pickEl = others.length ? randChoice(others) : randChoice(ELEMENTS);
      base = pickEl + " (Mutated)";
    }

    // Mystic: CHỈ với Forehead..Tail (body không mystic)
    if (i !== 0) {
      const alreadyMystic = /^mystic$/i.test(base.trim());
      if (!alreadyMystic && Math.random() < cfg.pMystic) {
        base = "Mystic";
      }
    }

    out.push(base);

    // Lưu element của body nếu không phải Mystic
    if (i === 0 && !/mystic/i.test(base)) {
      bodyElement = normalizeElement(base);
    }
  }

  const gender = Math.random() < 0.5 ? "male" : "female";
  return { gender, parts: out };
}
